import sys
import os
import numpy as np
from scipy import signal
import unwrap
import abel
import matplotlib.pyplot as plt
import matplotlib.patches as patches
from mpl_toolkits.axes_grid1 import make_axes_locatable

import fittools

class PPDD(object):
    """
    Python Plasma Density Diagnostics(PPDD) is the main class to read input data, perform abel transfrom and output transfrom result.
    A run should consists of methods in the following order:
    readfile
    find_peaks
    filt_move
    find_symmetry_axis
    abel
    """
    def __init__(self, xmin = 0, xmax = 800, ymin = 400, ymax = 600, xband = 0.01, yband = 0.1, symin = 50, symax = 150, **kwargs):
        self.guess = fittools.Guess(**kwargs);
        self.xmin = xmin        #crop the region [ymin:ymax, xmin:xmax] from raw input data
        self.xmax = xmax
        self.ymin = ymin
        self.ymax = ymax
        self.xband = xband      #half passbands for filter in x and y direction
        self.yband = yband
        self.symin = symin      #limits the symmetry axis finding to [symin, symax]
        self.symax = symax
        self.peak_fitted = False

        self.abel_methods = {
            "hansenlaw": self.abel_hansenlaw,
            "onion_bordas": self.abel_onion_bordas,
            "basex": self.abel_basex
        }

    def readfile(self, filename):
        """
        Read input file filename
        """
        self.rawdata = np.loadtxt(filename, dtype=int)
        self.peak_fitted = False

    def find_peaks(self):
        """
        Find the three peaks in the frequency spectrum of xy2d. 
        """
        self.xy2d = self.rawdata[self.ymin:self.ymax, self.xmin:self.xmax]
        self.fx, self.fy, self.XYf2d_shifted, newguess = fittools.find_peaks(self.xy2d, self.guess) 
        self.guess = newguess
        self.peak_fitted = True

    def filt_move(self):
        """
        Filt the image(2d-array) xy2d and move the second peak to center. fx and fy is generated by find_peaks. xband and yband are the passband halfwidth of filter on x and y direction respectively. Return the phase spectrum.
        """
        length_x = self.xy2d.shape[1]
        length_y = self.xy2d.shape[0]
        x_filter_length = (length_x//3+1)//2*2-1      #must be odd
        y_filter_length = (length_y//3+1)//2*2-1      #must be odd
        #Filter on x direction
        b = signal.firwin(x_filter_length, cutoff=[self.fx*2-self.xband, self.fx*2+self.xband], window=('kaiser',8), pass_zero=False)
        a = np.zeros([x_filter_length])
        a[0] = 1
        xy2df = signal.filtfilt(b, a, self.xy2d)
        #Filter on y direction
        b = signal.firwin(y_filter_length, cutoff=self.fy+self.yband, window=('kaiser',8), pass_zero=True)
        a = np.zeros([y_filter_length])
        a[0] = 1
        xy2df = signal.filtfilt(b, a, xy2df, axis = 0)

        #Remove negative frequencies
        XYf2df = np.fft.fftn(xy2df)
        XYf2df[:,length_x//2:]=0
        #Shift second peak to center
        xy2df0 = np.fft.ifftn(XYf2df)
        phase = np.angle(xy2df0)
        shifter_x = np.arange(length_x)
        phase += shifter_x*(-2*np.pi*self.fx)
        shifter_y = np.arange(length_y)[:,np.newaxis]
        phase += shifter_y*(-2*np.pi*self.fy)

        #Unwrap
        phase = (phase+np.pi) % (2*np.pi) - np.pi
        self.phase = unwrap.unwrap(phase)

    def find_symmetry_axis(self):
        self.ycenter = fittools.find_symmetry_axis(self.phase, self.symin, self.symax)

    def abel(self, method = 'hansenlaw'):
        IM = fittools.half_image(self.phase.transpose(), self.ycenter)
        self.abel_methods[method](IM)

    def abel_hansenlaw(self, IM):
        self.AIM = abel.hansenlaw.hansenlaw_transform(IM, direction = 'inverse').transpose()

    def abel_onion_bordas(self, IM):
        self.AIM = abel.onion_bordas.onion_bordas_transform(IM, direction = 'inverse').transpose()

    def abel_basex(self, IM):
        self.AIM = abel.basex.basex_transform(IM, basis_dir=os.path.join(os.path.dirname(os.path.realpath(sys.argv[0])), 'basex'), direction='inverse').transpose()


def main():
    #create a PPDD object
    pyppd = PPDD()
    failed_reads = []
    failed_peaks = []
    failed_symmetries = []

    #Read Data
    for filename in sys.argv[1:]:
        try :
            pyppd.readfile(filename)
        except :
            failed_reads.append(filename)
            continue
        #Fit three peaks to find the secondary peak
        try :
            pyppd.find_peaks()
        except RuntimeError :
            failed_peaks.append(filename)
            continue
        #Filter
        pyppd.filt_move()
        #Find the center of phase spectrum
        try :
            pyppd.find_symmetry_axis()
        except RuntimeError :       #currently not possible because find_symmetry_axis always give a center in [ymin, ymax]
            failed_symmetries.append(filename)
            continue
        #Abel transform
        try :
            pyppd.abel()
        except ValueError :     #given invalid symmetry axis
            failed_symmetries.append(filename)
            continue

        #Plot
        plt.close("all")
        f, ((ax1, ax2), (ax3, ax4)) = plt.subplots(2, 2, figsize=(20,10))

        ax1.set_title('Raw data')
        im1 = ax1.pcolormesh(pyppd.rawdata)
        rect1 = patches.Rectangle((pyppd.xmin, pyppd.ymin), pyppd.xmax-pyppd.xmin, pyppd.ymax-pyppd.ymin, linewidth=2, edgecolor='r', facecolor='none')
        ax1.set_xlim(0, pyppd.rawdata.shape[1])
        ax1.set_ylim(0, 800)
        ax1.add_patch(rect1)

        ax2.set_title('Phase spectrum')
        im2 = ax2.pcolormesh(pyppd.phase)
        ax2.hlines(pyppd.ycenter, 0, pyppd.phase.shape[1], linewidth=3, colors='black')
        divider2 = make_axes_locatable(ax2)
        cax2 = divider2.append_axes("right", size="5%", pad=0.05)
        plt.colorbar(im2, cax2)

        ax3.set_title('Amplitude spectrum')
        XYf2d_shifted = pyppd.XYf2d_shifted
        im3 = ax3.pcolormesh(np.fft.fftshift(np.fft.fftfreq(XYf2d_shifted.shape[1])), np.fft.fftshift(np.fft.fftfreq(XYf2d_shifted.shape[0])), XYf2d_shifted,vmax=1e6)
        ax3.set_xlim(-0.2,0.2)
        ax3.set_ylim(-0.2,0.2)
        rect3 = patches.Rectangle((pyppd.fx-pyppd.xband,-np.abs(pyppd.fy)-pyppd.yband), 2*pyppd.xband, 2*(pyppd.yband+np.abs(pyppd.fy)), linewidth=2, edgecolor='r', facecolor='none')
        ax3.add_patch(rect3)

        ax4.set_title('Relative Refractivity')
        im4 = ax4.pcolormesh(pyppd.AIM, vmax=0.1, vmin=0)
        divider4 = make_axes_locatable(ax4)
        cax4 = divider4.append_axes("right", size="5%", pad=0.05)
        plt.colorbar(im4, cax4)

        outputpath = os.path.join(os.path.dirname(os.path.realpath(sys.argv[0])), 'output')
        os.makedirs(outputpath, exist_ok=True)
        plt.savefig(os.path.join(outputpath, os.path.basename(filename).rsplit('.', 1)[0]+'.png'), bbox_inches='tight')
        plt.close()

    if failed_reads:
        print("Failed to read these input files:", file=sys.stderr)
        for i in failed_reads:
            print(i, file=sys.stderr)
    if failed_peaks:
        print("Failed to find the secondary peak in these input files:", file=sys.stderr)
        for i in failed_peaks:
            print(i, file=sys.stderr)
    if failed_symmetries:
        print("Failed to find the symmetry axis of phase spectrum in these input files:", file=sys.stderr)
        for i in failed_symmetries:
            print(i, file=sys.stderr)

    return 0

if __name__ == "__main__":
    main()
